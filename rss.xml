<?xml version='1.0' encoding='utf-8'?>
<rss xmlns:ns0="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>Daily Kotlin Tip</title>
    <link>https://oliviermarteaux.github.io/DailyKotlinTip/</link>
    <description>Auto‑generated Kotlin advice</description>
    <ns0:link href="https://oliviermarteaux.github.io/DailyKotlinTip/" rel="self" />
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Jul 2025 07:25:29 GMT</lastBuildDate>
    <image>
      <url>https://oliviermarteaux.github.io/DailyKotlinTip/icon.png</url>
      <title>Daily Kotlin Tip</title>
      <link>https://oliviermarteaux.github.io/DailyKotlinTip/</link>
      </image>
    <item>
      <title>Utilizing State Hoisting in Jetpack Compose</title>
      <link>https://oliviermarteaux.github.io/DailyKotlinTip/articles/20250715072529.html</link>
      <description>&lt;h2&gt;Utilizing State Hoisting in Jetpack Compose&lt;/h2&gt;
&lt;p&gt;State hoisting is a powerful concept in Jetpack Compose that allows you to manage state in a way that keeps your composables simple and focused on displaying UI. By hoisting state, you can separate the state management from the UI logic, making your code more reusable and easier to test. This is especially useful when you have multiple composables that need to share or react to the same state.&lt;/p&gt;
&lt;pre style="background-color: #8a428a; color: white; padding: 12px; border-radius: 8px; font-size: 10px; overflow-x: auto;"&gt;
&lt;code&gt;
@Composable
fun Counter() {
    var count by remember { mutableStateOf(0) }

    Column {
        Text(text = "Count: $count")
        Button(onClick = { count++ }) {
            Text("Increment")
        }
    }
}

@Composable
fun ParentComposable() {
    var count by remember { mutableStateOf(0) }

    Counter(count = count, onCountChange = { count = it })
}

@Composable
fun Counter(count: Int, onCountChange: (Int) -&gt; Unit) {
    Column {
        Text(text = "Count: $count")
        Button(onClick = { onCountChange(count + 1) }) {
            Text("Increment")
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
      <pubDate>Tue, 15 Jul 2025 07:25:29 GMT</pubDate>
      <guid>https://oliviermarteaux.github.io/DailyKotlinTip/articles/20250715072529.html</guid>
      </item>
    <item>
      <title>Using State in Jetpack Compose for Reactive UI</title>
      <link>https://oliviermarteaux.github.io/DailyKotlinTip/articles/20250714191129.html</link>
      <description>&lt;h2&gt;Using State in Jetpack Compose for Reactive UI&lt;/h2&gt;
&lt;p&gt;In Jetpack Compose, managing UI state efficiently is crucial for creating responsive applications. By leveraging the state management capabilities of Compose, you can ensure that your UI updates automatically when the underlying data changes. A common practice is to use &lt;code&gt;remember&lt;/code&gt; and &lt;code&gt;mutableStateOf&lt;/code&gt; to hold the state of your composables. This allows your UI to react to changes without the need for complex lifecycle management.&lt;/p&gt;
&lt;pre style="background-color: #8a428a; color: white; padding: 12px; border-radius: 8px; font-size: 10px; overflow-x: auto;"&gt;
&lt;code&gt;import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.material.Text
import androidx.compose.material.Button

@Composable
fun Counter() {
    val count = remember { mutableStateOf(0) }

    Button(onClick = { count.value++ }) {
        Text(text = "Count: ${count.value}")
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
      <pubDate>Mon, 14 Jul 2025 19:11:29 GMT</pubDate>
      <guid>https://oliviermarteaux.github.io/DailyKotlinTip/articles/20250714191129.html</guid>
      </item>
    <item>
      <title>Leveraging State in Jetpack Compose for Dynamic UI Updates</title>
      <link>https://oliviermarteaux.github.io/DailyKotlinTip/articles/20250714182637.html</link>
      <description>&lt;h2&gt;Leveraging State in Jetpack Compose for Dynamic UI Updates&lt;/h2&gt;
&lt;p&gt;
In Jetpack Compose, managing state effectively is crucial for building responsive and dynamic UIs. By using &lt;code&gt;remember&lt;/code&gt; and &lt;code&gt;mutableStateOf&lt;/code&gt;, you can create a UI that reacts to user interactions seamlessly. This approach follows best practices recommended by Google, ensuring that your UI components are only recomposed when necessary, thus improving performance. 
&lt;/p&gt;
&lt;p&gt;
Here’s a simple example of a counter application that demonstrates how to use state in Jetpack Compose:
&lt;/p&gt;
&lt;pre style="background-color: #8a428a; color: white; padding: 12px; border-radius: 8px; font-size: 13px; overflow-x: auto;"&gt;
&lt;code&gt;
@Composable
fun Counter() {
    // Remember the count state
    val count = remember { mutableStateOf(0) }

    // UI layout
    Column(horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center) {
        Text(text = "Count: ${count.value}", fontSize = 24.sp)
        Spacer(modifier = Modifier.height(16.dp))
        Button(onClick = { count.value++ }) {
            Text("Increment")
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
      <pubDate>Mon, 14 Jul 2025 18:26:37 GMT</pubDate>
      <guid>https://oliviermarteaux.github.io/DailyKotlinTip/articles/20250714182637.html</guid>
      </item>
    </channel>
  </rss>
